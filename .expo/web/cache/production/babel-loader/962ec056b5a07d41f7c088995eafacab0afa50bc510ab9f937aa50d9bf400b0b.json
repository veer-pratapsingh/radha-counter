{"ast":null,"code":"import inRange from'lodash/inRange';import XDate from'xdate';import constants from'../commons/constants';export const HOUR_BLOCK_HEIGHT=100;const OVERLAP_EVENTS_SPACINGS=10;const RIGHT_EDGE_SPACING=10;function buildEvent(event,left,width,{dayStart=0,hourBlockHeight=HOUR_BLOCK_HEIGHT}){const startTime=new XDate(event.start);const endTime=event.end?new XDate(event.end):new XDate(startTime).addHours(1);const dayStartTime=new XDate(startTime).clearTime();return Object.assign({},event,{top:(dayStartTime.diffHours(startTime)-dayStart)*hourBlockHeight,height:startTime.diffHours(endTime)*hourBlockHeight,width,left});}function hasCollision(a,b){return a.end>b.start&&a.start<b.end;}function calcColumnSpan(event,columnIndex,columns){let colSpan=1;for(let i=columnIndex+1;i<columns.length;i++){const column=columns[i];const foundCollision=column.find(ev=>hasCollision(event,ev));if(foundCollision){return colSpan;}colSpan++;}return colSpan;}function packOverlappingEventGroup(columns,calculatedEvents,populateOptions){const{screenWidth=constants.screenWidth,rightEdgeSpacing=RIGHT_EDGE_SPACING,overlapEventsSpacing=OVERLAP_EVENTS_SPACINGS}=populateOptions;columns.forEach((column,columnIndex)=>{column.forEach(event=>{const totalWidth=screenWidth-rightEdgeSpacing;const columnSpan=calcColumnSpan(event,columnIndex,columns);const eventLeft=columnIndex/columns.length*totalWidth;let eventWidth=totalWidth*(columnSpan/columns.length);if(columnIndex+columnSpan<=columns.length-1){eventWidth-=overlapEventsSpacing;}calculatedEvents.push(buildEvent(event,eventLeft,eventWidth,populateOptions));});});}export function populateEvents(_events,populateOptions){let lastEnd=null;let columns=[];const calculatedEvents=[];const events=_events.map((ev,index)=>Object.assign({},ev,{index:index})).sort(function(a,b){if(a.start<b.start)return-1;if(a.start>b.start)return 1;if(a.end<b.end)return-1;if(a.end>b.end)return 1;return 0;});events.forEach(function(ev){if(lastEnd!==null&&ev.start>=lastEnd){packOverlappingEventGroup(columns,calculatedEvents,populateOptions);columns=[];lastEnd=null;}let placed=false;for(let i=0;i<columns.length;i++){const col=columns[i];if(!hasCollision(col[col.length-1],ev)){col.push(ev);placed=true;break;}}if(!placed){columns.push([ev]);}if(lastEnd===null||ev.end>lastEnd){lastEnd=ev.end;}});if(columns.length>0){packOverlappingEventGroup(columns,calculatedEvents,populateOptions);}return calculatedEvents;}export function buildUnavailableHoursBlocks(unavailableHours=[],options){const{hourBlockHeight=HOUR_BLOCK_HEIGHT,dayStart=0,dayEnd=24}=options||{};const totalDayHours=dayEnd-dayStart;const totalDayHeight=(dayEnd-dayStart)*hourBlockHeight;return unavailableHours.map(hours=>{if(!inRange(hours.start,0,25)||!inRange(hours.end,0,25)){console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');return undefined;}if(hours.start>=hours.end){console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');return undefined;}const startFixed=Math.max(hours.start,dayStart);const endFixed=Math.min(hours.end,dayEnd);return{top:(startFixed-dayStart)/totalDayHours*totalDayHeight,height:(endFixed-startFixed)*hourBlockHeight};}).filter(Boolean);}","map":{"version":3,"names":["inRange","XDate","constants","HOUR_BLOCK_HEIGHT","OVERLAP_EVENTS_SPACINGS","RIGHT_EDGE_SPACING","buildEvent","event","left","width","dayStart","hourBlockHeight","startTime","start","endTime","end","addHours","dayStartTime","clearTime","Object","assign","top","diffHours","height","hasCollision","a","b","calcColumnSpan","columnIndex","columns","colSpan","i","length","column","foundCollision","find","ev","packOverlappingEventGroup","calculatedEvents","populateOptions","screenWidth","rightEdgeSpacing","overlapEventsSpacing","forEach","totalWidth","columnSpan","eventLeft","eventWidth","push","populateEvents","_events","lastEnd","events","map","index","sort","placed","col","buildUnavailableHoursBlocks","unavailableHours","options","dayEnd","totalDayHours","totalDayHeight","hours","console","error","undefined","startFixed","Math","max","endFixed","min","filter","Boolean"],"sources":["C:/Users/chaud/radha-counter/node_modules/react-native-calendars/src/timeline/Packer.js"],"sourcesContent":["import inRange from 'lodash/inRange';\nimport XDate from 'xdate';\nimport constants from '../commons/constants';\nexport const HOUR_BLOCK_HEIGHT = 100;\nconst OVERLAP_EVENTS_SPACINGS = 10;\nconst RIGHT_EDGE_SPACING = 10;\nfunction buildEvent(event, left, width, { dayStart = 0, hourBlockHeight = HOUR_BLOCK_HEIGHT }) {\n    const startTime = new XDate(event.start);\n    const endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n    const dayStartTime = new XDate(startTime).clearTime();\n    return {\n        ...event,\n        top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n        height: startTime.diffHours(endTime) * hourBlockHeight,\n        width,\n        left\n    };\n}\nfunction hasCollision(a, b) {\n    return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n    let colSpan = 1;\n    for (let i = columnIndex + 1; i < columns.length; i++) {\n        const column = columns[i];\n        const foundCollision = column.find(ev => hasCollision(event, ev));\n        if (foundCollision) {\n            return colSpan;\n        }\n        colSpan++;\n    }\n    return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n    const { screenWidth = constants.screenWidth, rightEdgeSpacing = RIGHT_EDGE_SPACING, overlapEventsSpacing = OVERLAP_EVENTS_SPACINGS } = populateOptions;\n    columns.forEach((column, columnIndex) => {\n        column.forEach(event => {\n            const totalWidth = screenWidth - rightEdgeSpacing;\n            const columnSpan = calcColumnSpan(event, columnIndex, columns);\n            const eventLeft = (columnIndex / columns.length) * totalWidth;\n            let eventWidth = totalWidth * (columnSpan / columns.length);\n            if (columnIndex + columnSpan <= columns.length - 1) {\n                eventWidth -= overlapEventsSpacing;\n            }\n            calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n        });\n    });\n}\nexport function populateEvents(_events, populateOptions) {\n    let lastEnd = null;\n    let columns = [];\n    const calculatedEvents = [];\n    const events = _events\n        .map((ev, index) => ({ ...ev, index: index }))\n        .sort(function (a, b) {\n        if (a.start < b.start)\n            return -1;\n        if (a.start > b.start)\n            return 1;\n        if (a.end < b.end)\n            return -1;\n        if (a.end > b.end)\n            return 1;\n        return 0;\n    });\n    events.forEach(function (ev) {\n        // Reset recent overlapping event group and start a new one\n        if (lastEnd !== null && ev.start >= lastEnd) {\n            packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n            columns = [];\n            lastEnd = null;\n        }\n        // Place current event in the right column where it doesn't overlap\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (!hasCollision(col[col.length - 1], ev)) {\n                col.push(ev);\n                placed = true;\n                break;\n            }\n        }\n        // If curr event wasn't placed in any of the columns, create a new column for it\n        if (!placed) {\n            columns.push([ev]);\n        }\n        if (lastEnd === null || ev.end > lastEnd) {\n            lastEnd = ev.end;\n        }\n    });\n    if (columns.length > 0) {\n        packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n    }\n    return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks(unavailableHours = [], options) {\n    const { hourBlockHeight = HOUR_BLOCK_HEIGHT, dayStart = 0, dayEnd = 24 } = options || {};\n    const totalDayHours = dayEnd - dayStart;\n    const totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n    return (unavailableHours\n        .map(hours => {\n        if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n            console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n            return undefined;\n        }\n        if (hours.start >= hours.end) {\n            console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n            return undefined;\n        }\n        const startFixed = Math.max(hours.start, dayStart);\n        const endFixed = Math.min(hours.end, dayEnd);\n        return {\n            top: ((startFixed - dayStart) / totalDayHours) * totalDayHeight,\n            height: (endFixed - startFixed) * hourBlockHeight\n        };\n    })\n        // Note: this filter falsy values (undefined blocks)\n        .filter(Boolean));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}