{"ast":null,"code":"export class EventEmitter {\n  addListener(eventName, listener) {\n    if (!this.listeners) {\n      this.listeners = new Map();\n    }\n    if (!this.listeners?.has(eventName)) {\n      this.listeners?.set(eventName, new Set());\n    }\n    const previousListenerCount = this.listenerCount(eventName);\n    this.listeners?.get(eventName)?.add(listener);\n    if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {\n      this.startObserving(eventName);\n    }\n    return {\n      remove: () => {\n        this.removeListener(eventName, listener);\n      }\n    };\n  }\n  removeListener(eventName, listener) {\n    const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);\n    if (this.listenerCount(eventName) === 0 && hasRemovedListener) {\n      this.stopObserving(eventName);\n    }\n  }\n  removeAllListeners(eventName) {\n    const previousListenerCount = this.listenerCount(eventName);\n    this.listeners?.get(eventName)?.clear();\n    if (previousListenerCount > 0) {\n      this.stopObserving(eventName);\n    }\n  }\n  emit(eventName, ...args) {\n    const listeners = new Set(this.listeners?.get(eventName));\n    listeners.forEach(listener => {\n      try {\n        listener(...args);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n  listenerCount(eventName) {\n    return this.listeners?.get(eventName)?.size ?? 0;\n  }\n  startObserving(eventName) {}\n  stopObserving(eventName) {}\n}\nexport class NativeModule extends EventEmitter {}\nexport class SharedObject extends EventEmitter {\n  release() {}\n}\nexport class SharedRef extends SharedObject {\n  nativeRefType = 'unknown';\n}","map":{"version":3,"names":["EventEmitter","addListener","eventName","listener","listeners","Map","has","set","Set","previousListenerCount","listenerCount","get","add","startObserving","remove","removeListener","hasRemovedListener","delete","stopObserving","removeAllListeners","clear","emit","args","forEach","error","console","size","NativeModule","SharedObject","release","SharedRef","nativeRefType"],"sources":["C:/Users/chaud/radha-counter/node_modules/expo-modules-core/src/web/CoreModule.ts"],"sourcesContent":["import {\n  type EventEmitter as EventEmitterType,\n  type EventSubscription,\n  EventsMap,\n} from '../ts-declarations/EventEmitter';\nimport type { NativeModule as NativeModuleType } from '../ts-declarations/NativeModule';\nimport type { SharedObject as SharedObjectType } from '../ts-declarations/SharedObject';\nimport type { SharedRef as SharedRefType } from '../ts-declarations/SharedRef';\n\nexport class EventEmitter<TEventsMap extends EventsMap> implements EventEmitterType {\n  private listeners?: Map<keyof TEventsMap, Set<Function>>;\n\n  addListener<EventName extends keyof TEventsMap>(\n    eventName: EventName,\n    listener: TEventsMap[EventName]\n  ): EventSubscription {\n    if (!this.listeners) {\n      this.listeners = new Map();\n    }\n    if (!this.listeners?.has(eventName)) {\n      this.listeners?.set(eventName, new Set());\n    }\n\n    const previousListenerCount = this.listenerCount(eventName);\n\n    this.listeners?.get(eventName)?.add(listener);\n\n    if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {\n      this.startObserving(eventName);\n    }\n\n    return {\n      remove: () => {\n        this.removeListener(eventName, listener);\n      },\n    };\n  }\n\n  removeListener<EventName extends keyof TEventsMap>(\n    eventName: EventName,\n    listener: TEventsMap[EventName]\n  ): void {\n    const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);\n    if (this.listenerCount(eventName) === 0 && hasRemovedListener) {\n      this.stopObserving(eventName);\n    }\n  }\n\n  removeAllListeners<EventName extends keyof TEventsMap>(eventName: EventName): void {\n    const previousListenerCount = this.listenerCount(eventName);\n    this.listeners?.get(eventName)?.clear();\n    if (previousListenerCount > 0) {\n      this.stopObserving(eventName);\n    }\n  }\n\n  emit<EventName extends keyof TEventsMap>(\n    eventName: EventName,\n    ...args: Parameters<TEventsMap[EventName]>\n  ): void {\n    const listeners = new Set(this.listeners?.get(eventName));\n\n    listeners.forEach((listener) => {\n      // When the listener throws an error, don't stop the execution of subsequent listeners and\n      // don't propagate the error to the `emit` function. The motivation behind this is that\n      // errors thrown from a module or user's code shouldn't affect other modules' behavior.\n      try {\n        listener(...args);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  listenerCount<EventName extends keyof TEventsMap>(eventName: EventName): number {\n    return this.listeners?.get(eventName)?.size ?? 0;\n  }\n\n  startObserving<EventName extends keyof TEventsMap>(eventName: EventName): void {}\n\n  stopObserving<EventName extends keyof TEventsMap>(eventName: EventName): void {}\n}\n\nexport class NativeModule<TEventsMap extends Record<never, never>>\n  extends EventEmitter<TEventsMap>\n  implements NativeModuleType\n{\n  [key: string]: any;\n  ViewPrototypes?: { [viewName: string]: object };\n  __expo_module_name__?: string;\n}\n\nexport class SharedObject<TEventsMap extends Record<never, never>>\n  extends EventEmitter<TEventsMap>\n  implements SharedObjectType\n{\n  release(): void {\n    // no-op on Web, but subclasses can override it if needed.\n  }\n}\n\nexport class SharedRef<\n    TNativeRefType extends string = 'unknown',\n    TEventsMap extends EventsMap = Record<never, never>,\n  >\n  extends SharedObject<TEventsMap>\n  implements SharedRefType<TNativeRefType>\n{\n  nativeRefType: string = 'unknown';\n}\n"],"mappings":"AASA,OAAO,MAAMA,YAAY,CAA2D;EAGlFC,WAAWA,CACTC,SAAoB,EACpBC,QAA+B,EACZ;IACnB,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;MACnB,IAAI,CAACA,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC5B;IACA,IAAI,CAAC,IAAI,CAACD,SAAS,EAAEE,GAAG,CAACJ,SAAS,CAAC,EAAE;MACnC,IAAI,CAACE,SAAS,EAAEG,GAAG,CAACL,SAAS,EAAE,IAAIM,GAAG,CAAC,CAAC,CAAC;IAC3C;IAEA,MAAMC,qBAAqB,GAAG,IAAI,CAACC,aAAa,CAACR,SAAS,CAAC;IAE3D,IAAI,CAACE,SAAS,EAAEO,GAAG,CAACT,SAAS,CAAC,EAAEU,GAAG,CAACT,QAAQ,CAAC;IAE7C,IAAIM,qBAAqB,KAAK,CAAC,IAAI,IAAI,CAACC,aAAa,CAACR,SAAS,CAAC,KAAK,CAAC,EAAE;MACtE,IAAI,CAACW,cAAc,CAACX,SAAS,CAAC;IAChC;IAEA,OAAO;MACLY,MAAM,EAAEA,CAAA,KAAM;QACZ,IAAI,CAACC,cAAc,CAACb,SAAS,EAAEC,QAAQ,CAAC;MAC1C;IACF,CAAC;EACH;EAEAY,cAAcA,CACZb,SAAoB,EACpBC,QAA+B,EACzB;IACN,MAAMa,kBAAkB,GAAG,IAAI,CAACZ,SAAS,EAAEO,GAAG,CAACT,SAAS,CAAC,EAAEe,MAAM,CAACd,QAAQ,CAAC;IAC3E,IAAI,IAAI,CAACO,aAAa,CAACR,SAAS,CAAC,KAAK,CAAC,IAAIc,kBAAkB,EAAE;MAC7D,IAAI,CAACE,aAAa,CAAChB,SAAS,CAAC;IAC/B;EACF;EAEAiB,kBAAkBA,CAAqCjB,SAAoB,EAAQ;IACjF,MAAMO,qBAAqB,GAAG,IAAI,CAACC,aAAa,CAACR,SAAS,CAAC;IAC3D,IAAI,CAACE,SAAS,EAAEO,GAAG,CAACT,SAAS,CAAC,EAAEkB,KAAK,CAAC,CAAC;IACvC,IAAIX,qBAAqB,GAAG,CAAC,EAAE;MAC7B,IAAI,CAACS,aAAa,CAAChB,SAAS,CAAC;IAC/B;EACF;EAEAmB,IAAIA,CACFnB,SAAoB,EACpB,GAAGoB,IAAuC,EACpC;IACN,MAAMlB,SAAS,GAAG,IAAII,GAAG,CAAC,IAAI,CAACJ,SAAS,EAAEO,GAAG,CAACT,SAAS,CAAC,CAAC;IAEzDE,SAAS,CAACmB,OAAO,CAAEpB,QAAQ,IAAK;MAI9B,IAAI;QACFA,QAAQ,CAAC,GAAGmB,IAAI,CAAC;MACnB,CAAC,CAAC,OAAOE,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;MACtB;IACF,CAAC,CAAC;EACJ;EAEAd,aAAaA,CAAqCR,SAAoB,EAAU;IAC9E,OAAO,IAAI,CAACE,SAAS,EAAEO,GAAG,CAACT,SAAS,CAAC,EAAEwB,IAAI,IAAI,CAAC;EAClD;EAEAb,cAAcA,CAAqCX,SAAoB,EAAQ,CAAC;EAEhFgB,aAAaA,CAAqChB,SAAoB,EAAQ,CAAC;AACjF;AAEA,OAAO,MAAMyB,YAAY,SACf3B,YAAY,CAEtB;AAMA,OAAO,MAAM4B,YAAY,SACf5B,YAAY,CAEtB;EACE6B,OAAOA,CAAA,EAAS,CAEhB;AACF;AAEA,OAAO,MAAMC,SAAS,SAIZF,YAAY,CAEtB;EACEG,aAAa,GAAW,SAAS;AACnC","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}